{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 CourierNewPSMT;}
{\colortbl;\red255\green255\blue255;}
{\info
{\author David Parry}
{\*\company LIMM Leeds}}\vieww19420\viewh23500\viewkind1\viewscale150
\deftab720
\pard\pardeftab720\ri0

\f0\fs24 \cf0 These scripts are written primarily with a view to assisting mutation discovery in Mendelian disease. They have been tested on data generated using 
\b GATK variant callers
\b0  (UnifiedGenotyper and HaplotypeCaller) but should work with data generate in VCF format from other variant callers. When using tools such as 
\b findBiallelicVep.pl 
\b0 or
\b  filterOnSample.pl
\b0  it is assumed that you are using a 
\b multisample
\b0  VCF as input.  To run the scripts either add the enclosing directory to your PATH and make sure the scripts are executable or run each script using 'perl [location of script]' followed by the required arguments. Help information is available for each script by running the script with either '--help' or '--manual' options. You will probably need to install additional perl modules from CPAN (http://www.cpan.org/modules/INSTALL.html) in order to run these programs.\
\
The following scripts support parallel execution using 
\b forks
\b0 :\
\
\pard\pardeftab720\ri0

\b \cf0     annotateSnps.pl\
    filterOnEvsMaf.pl\
    filterVcfOnVcf.pl\
    filterOnSample.pl\
    sampleCallsToInfo.pl \
\pard\pardeftab720\ri0

\b0 \cf0 \
Use the 
\b --forks
\b0  option with these programs to specify the number of forks to use (if desired). It is probably a bad idea to specify more forks than there are CPU cores on your machine and these scripts will warn you if this happens.  \
\
Examples are given below of what are envisaged to be typical uses of these programs. They are only intended as guidelines for use of some of these programs in order to get people started with these tools. \
\
\pard\pardeftab720\ri0

\b \cf0 FILTERING VARIANTS:
\b0 \
\
Typically we may first want to remove common variation from a VCF. The example below is typical for processing data relating to a rare recessive condiation. It removes variants in the dbSnp VCF file (dbSnp138.b37.vcf.gz) present at build 129 (generally considered the last build before 'contamination' with data from large sequencing projects) or with a minor allele frequency (MAF) of 1 % or higher in later build versions.  However, any variant with a 'Pathogenic' or 'Probably Pathogenic' annotation in the ClinVar VCF file (clinvar_20130506.vcf) will be retained regardless of frequency or dbSNP build. We optionally use the --progress flag to show a progressbar as variants are processed.\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl annotateSnps.pl -d dbSnp138.b37.vcf.gz clinvar_20130506.vcf -b 129 -f 1 --pathogenic -i input.vcf -o input_snpfiltered.vcf --progress\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
Similarly, we may want to use data from the NHLBI Exome Sequencing Project (ESP) to filter common variants. Below we filter any variant with a MAF of 1 % or higher in the ESP VCF files present in the directory passed to the -d argument:\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl filterOnEvsMaf.pl -i input_snpfiltered.vcf -o input_snpfiltered_evsfiltered.vcf -f 1 -d ~/ESP_vcfs --progress\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
Having filtered common variation from dbSNP and ESP databases we may want to filter variants present in other VCFs (e.g. control samples sequenced locally).\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl filterVcfOnVcf.pl -i input_snpfiltered_evsfiltered.vcf -f controls.vcf -o input_snpfiltered_evsfiltered_vcffiltered.vcf\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
If we have a multisample VCF we may want to only keep variants present in our sample of interest or family members:\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl filterOnSample.pl -i input_snpfiltered_evsfiltered_vcffiltered.vcf -s Sample1 Sample2 -x Sample3 Sample4 -o input_snpfiltered_evsfiltered_vcffiltered_samplefiltered.vcf
\f0\fs24 \
\
In the example above Sample1 and Sample2 might be affected individuals while Sample3 and Sample4 could be unaffected family members who are potential carriers. The 
\b filterOnSample.pl
\b0  program will only output variants present in Sample1 and Sample2 but will ignore anything that is also present in any other sample in the VCF with the exception of Sample3 and Sample4. Alternatively you can explicitly specify which samples to use for filtering, such as the example below where variants are only kept if present in Sample1 and Sample2 but rejected if Control1 or Control2 contain the same variant:\
\

\f1\fs22 perl filterOnSample.pl -i input_snpfiltered_evsfiltered_vcffiltered.vcf -s Sample1 Sample2 -r Control1 Control2 -o input_snpfiltered_evsfiltered_vcffiltered_samplefiltered.vcf\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
The above might be useful for identifying mutations with dominant inheritance patterns by identifying mutations only present in affected samples. See the full documentation for filterOnSample.pl \
\
At this point, you may want to identify variants that have potentially pathogenic functional consequences on gene products. In order to do so you will need to have annotated your VCF with functional consequences using either 
\b Ensembl's Variant Effect Predictor
\b0  (http://www.ensembl.org/info/docs/tools/vep/index.html) or 
\b SnpEff
\b0  (http://snpeff.sourceforge.net/).  You can filter this VCF using 
\b getFunctionalVariantsVep.pl/getFunctionalVariantsSnpEff.pl 
\b0 or
\b  findBiallelicVep.pl/findBiallelicSnpEff.pl 
\b0 depending on your needs.  Below is an example using findBiallelicVep.pl to identify potential compound heterozygous or homozygous 'functional' variants present in Sample1 and Sample2 (they are related so we are  using the -e flag to specify that we expect both to contain the same causative mutation) but not in Sample3 and Sample4 (unaffected family members):\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl findBiallelicVep.pl -i vep.input_snpfiltered_evsfiltered_vcffiltered.vcf -s Sample1 Sample2 -r Sample3 Sample4 -e -o output.vcf \
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
The above might be better acheived by using a PED file of the family instead:\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl findBiallelicVep.pl -i vep.input_snpfiltered_evsfiltered_vcffiltered.vcf -f family.ped -o output.vcf \
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
You might instead be looking at several unrelated samples with the same condition and want to identify shared genes with potential compound heterozygous or homozygous 'functional' variants (not necessarily the same causative variants in each sample). In the example below we look at four unrelated samples with the same condition and output variants for genes that have potential biallelic variation in 3 or more of the 4 samples:\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl findBiallelicVep.pl -i vep.input_snpfiltered_evsfiltered_vcffiltered.vcf -s Sample1 Sample2 Sample3 Sample4 -n 3 -o output.vcf -l shared_genes.txt\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
See the various options in the help documentation for findBiallelicVep.pl for more details on how to filter variants on VEP fields such as 1000 genomes allele frequency or PolyPhen predictions.\
\
The 
\b getFunctionalVariantsVep.pl
\b0  program identifies variants matching 'functional' criteria and can also be used to provide a list of gene IDs to ignore (e.g. lof tolerant genes).  You may want to use this program to filter genes on functional consequence when not looking for biallelic variation or to prefilter with a list of gene IDs before running findBiallelicVep.pl. You may also/instead want to use 
\b rankOnCaddScore.pl
\b0  to rank variants ignoring functional annotation using Combined Annotation Dependent Depletion (CADD) scores.\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl rankOnCaddScore.pl -i input.vcf -o cadd_ranked.vcf -c ~/cadd_score_files/*.gz -n not_found_cadd_scores.tsv
\f0\fs24 \
\
You may then want to submit your 'not_found_cadd_scores.tsv' to http://cadd.gs.washington.edu/score and rerun once you have downloaded and tabix indexed your missing results.\
\
\pard\pardeftab720\ri0

\b \cf0 ANNOTATING YOUR OUTPUT:\
\pard\pardeftab720\ri0

\b0 \cf0 \
Having filtered/ranked you variant calls you may want to annotate gene information using 
\b ensemblGeneAnnotator.pl
\b0  . You may either create your own database with ensemblGeneAnnotator or download a pre-build database from: \
\
    http://sourceforge.net/projects/vcfhacks/files/ensAnnotatorDatabase/\
\
Remember to unzip the database if you have downloaded the pre-built version. Annotation requires ensembl gene IDs annotated using Ensembl's variant effect predictor. \
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl ensemblGeneAnnotator.pl -i input.vcf -d ~/ensAnnotator -o annotated.vcf\
\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 You may only want to annotate gene information for 'functional' variants and omit information for overlapping genes with synonymous/intronic/UTR variants, in which case use a command like the the following:\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl ensemblGeneAnnotator.pl -i input.vcf -d ~/ensAnnotator -o annotated.vcf --functional\
\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 At this point you may wish to produce a spreadsheet of your results using 
\b annovcfToSimple.pl
\b0 . The following should create an Excel spreadsheet (.xlsx) from a VEP and ensemblGeneAnnotator.pl annotated file:\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl annovcfToSimple.pl -g -v -i input.vcf -o input.xlsx
\f0\fs24 \
\
If you have many samples in your VCF you may want to specify only a few using the --samples option or alternatively use the --summarise option to summarise the alleles and genotypes in your VCF rather than giving information for each sample.\
\
\
\pard\pardeftab720\ri0

\b \cf0 GETTING VARIANTS FROM COORDINATES:\
\pard\pardeftab720\ri0

\b0 \cf0 \
You may quickly obtain variants that lie within genomic regions (specified in a BED file or on the command line), overlap single genomic coordinates or match those of another VCF using getVariantsByLocation.pl. If an index does not already exist one will be created, which may take some time for large files, but once created retrieval of regions should be quick. Note that your input must be coordinate sorted for this to work, otherwise the program will error.\
\
To get variants from vars.vcf that lie within regions in bedfile regions.bed: \
 \
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl getVariantsByLocation.pl -i vars.vcf -b regions.bed
\f0\fs24  \
 \
To get variants from vars.vcf that lie within the region 1:2000000-50000000 and output to file filtered.vcf\
 \

\f1\fs22 perl getVariantsByLocation.pl -i vars.vcf -r 1:2000000-50000000 -o filtered.vcf
\f0\fs24 \
\
To get variants from vars.vcf that lie within regions in bedfile regions.bed or the region 1:2000000-50000000 and output to file filtered.vcf\
 \

\f1\fs22 perl getVariantsByLocation.pl -i vars.vcf -b regions.bed -r 1:2000000-50000000 -o filtered.vcf\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
To get variants from vars.vcf that overlap any variant in other.vcf \
 \
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl getVariantsByLocation.pl -i vars.vcf -v other.vcf\
\pard\pardeftab720\ri0

\f0\fs24 \cf0     \
To get variants from vars.vcf that match a variant in other.vcf\
 \
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl getVariantsByLocation.pl -i vars.vcf -v other.vcf --matching\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
To get variants from vars.vcf that overlap the coordinates 1:2000000 or 1:30000000: \
    \
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl getVariantsByLocation.pl -i vars.vcf -r 1:2000000 1:30000000 -o filtered.vcf\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
If you have a VCF that is no longer coordinate sorted (e.g. if you've ranked your variants on CADD scores), you may use filterVcfOnLocation.pl to output variants that lie within specific genomic regions. This may be significantly slower compared to using getVariantsByLocation.pl on an indexed VCF but is useful if you do not want to coordinate sort your file.\
\
To get variants from vars.vcf that lie within regions in bedfile regions.bed: \
    \
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl filterVcfOnLocation.pl -i vars.vcf -b regions.bed\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
To get variants from vars.vcf that lie within the region 1:2000000-50000000 and output to file filtered.vcf\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl filterVcfOnLocation.pl -i vars.vcf -r 1:2000000-50000000 -o filtered.vcf\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
\
\pard\pardeftab720\ri0

\b \cf0 MISC USEFUL TOOLS
\b0 \
\
If you need to sort a VCF in coordinate order use sortVcf.pl:\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl sortVcf.pl -i input.vcf -o output.vcf\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
To get the names of all samples and the total number of samples in a VCF use getSampleNames.pl\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl getSampleNames.pl -i vars.vcf\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
To get the total number of variants in a VCF:\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl countVariants.pl vars.vcf\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
To get a summary of the number of observed alleles and genotypes in a VCF use countVcfCalls.pl:\
    \
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl countVcfCalls.pl -i vars.vcf
\f0\fs24 \
\
If you want to see the sample names with ALT genotypes as well as the number of observed genotypes use the -r flag:\
    \

\f1\fs22 perl countVcfCalls.pl -i vars.vcf -r \
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
You can pipe to countVcfCalls.pl from STDIN by specifying '-' as the input file. So, if you have a particular variant you want compare counts for at position 1:2000000 you may use the following command:\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl getVariantsByLocation.pl -i vars.vcf -r 1:2000000 | perl countVcfCalls.pl -i -\
\pard\pardeftab720\ri0

\f0\fs24 \cf0 \
If you have a VCF with many hundreds to thousands of samples that you frequently use for filtering on allele frequency using filterVcfOnVcf.pl, you can summarise the allele counts with sampleCallsToInfo.pl:\
\
\pard\pardeftab720\ri0

\f1\fs22 \cf0 perl sampleCallsToInfo.pl -i vars.vcf -o summarised.vcf
\f0\fs24  \
\
For data from a VCF with many hundreds to thousands of samples, using a summarised VCF with filterVcfOnVcf.pl is likely to be a great deal quicker than using the original VCF. To filter on allele frequency or genotypes use filterVcfOnVcf.pl  with the --info_filter flag\
\

\f1\fs22 perl filterVcfOnVcf.pl -i input.vcf  -f summarised.vcf  -o filtered.vcf -y 0.01 --info_filter\
\
}